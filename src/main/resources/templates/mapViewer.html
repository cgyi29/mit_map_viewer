<!DOCTYPE html>
<html xmlns:th="http://www.w3.org/1999/html" lang="en">
    <th:head>
        <script th:inline="javascript">
            let pointCanvasId = 'pointMapCanvas';
            let polyLineCanvasId = 'polyLineMapCanvas';
            let polygonCanvasId = 'polygonMapCanvas';

            let zoom = 1;
            let panX = 0;
            let panY = 0;
            let dragStart = null;
            let currentCanvasId = '';

            async function pointTypeInit() {
                const response = await fetch('/mapData/Duraklar');
                const shapeData = await response.json();
                const bbox = await shapeData.bbox;
                const points = await shapeData.points;

                const mapCanvas = document.getElementById(pointCanvasId);
                if(mapCanvas.getContext) {
                    const ctx = mapCanvas.getContext('2d');
                    ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                    ctx.save();
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);

                    points.forEach(point => {
                        let trPoint = scalePoint(point.x, point.y, bbox, mapCanvas);
                        ctx.beginPath();
                        ctx.arc(trPoint.x, trPoint.y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                    ctx.restore();
                }
            }

            async function polygonTypeInit(){
                const response = await fetch('/mapData/KoyMahalle');
                const shapeData = await response.json();
                const bbox = await shapeData.bbox;
                const polygonDatas = await shapeData.polyTypeDatas;

                const mapCanvas = await document.getElementById(polygonCanvasId);
                if(mapCanvas.getContext){
                    const ctx = await mapCanvas.getContext('2d');
                    ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                    ctx.save();
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);

                    polygonDatas.forEach(function(polygonData){
                        polygonData.parts.forEach(function() {
                            ctx.beginPath();
                            drawLine(polygonData.points, bbox, mapCanvas, ctx);
                            ctx.fillStyle = "yellow";
                            ctx.fill();
                            ctx.stroke();
                        });
                    });
                    ctx.restore();
                }
            }

            async function polyLineInit(){
                const response = await fetch('/mapData/Hatlar');
                const shapeData = await response.json();
                const bbox = await shapeData.bbox;
                const polyLineDatas = await shapeData.polyTypeDatas;

                const mapCanvas = await document.getElementById(polyLineCanvasId);
                if(mapCanvas.getContext){
                    const ctx = await mapCanvas.getContext('2d');
                    ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                    ctx.save();
                    ctx.translate(panX, panY);
                    ctx.scale(zoom, zoom);

                    polyLineDatas.forEach(function(polylineData){
                        polylineData.parts.forEach(function() {
                            ctx.beginPath();
                            drawLine(polylineData.points, bbox, mapCanvas, ctx);
                            ctx.stroke();
                        });
                    });
                    ctx.restore();
                }
            }

            function scalePoint(x, y, bbox, canvas) {
                let transformX = ((bbox.maxX - x) / (bbox.maxX - bbox.minX)) * canvas.width;
                let transformY = ((bbox.maxY - y) / (bbox.maxY - bbox.minY)) * canvas.height;
                transformX = canvas.width - transformX;
                return { x: transformX, y: transformY };
            }

            function drawLine(points, bbox, canvas, ctx){
                points.forEach((start, index) => {
                    let point = scalePoint(points[index].x, points[index].y, bbox, canvas);
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
            }

            function scrollHandler(event) {
                event.preventDefault();
                const scaleAmount = 1.1;
                const preZoom = zoom;

                const mapCanvas = document.getElementById(currentCanvasId);
                const cursorX = event.clientX - mapCanvas.offsetLeft;
                const cursorY = event.clientY - mapCanvas.offsetTop;
                zoom *= event.deltaY < 0 ? scaleAmount : 1 / scaleAmount;
                panX -= cursorX * (zoom - preZoom);
                panY -= cursorY * (zoom - preZoom);

                drawCanvas();
            }

            function startDrag(event) {
                dragStart = { x: event.clientX - panX, y: event.clientY - panY };
            }

            function onDrag(event) {
                if (dragStart !== null) {
                    panX = event.clientX - dragStart.x;
                    panY = event.clientY - dragStart.y;
                    drawCanvas();
                }
            }

            function endDrag() {
                dragStart = null;
            }

            async function drawCanvas() {
                if(currentCanvasId === pointCanvasId) await pointTypeInit();
                if(currentCanvasId === polyLineCanvasId)  await polyLineInit();
                if(currentCanvasId === polygonCanvasId) await polygonTypeInit();
            }

            function addEvent(canvasId) {
                const canvas = document.getElementById(canvasId);
                canvas.addEventListener('wheel', (event) => { currentCanvasId = canvasId; scrollHandler(event); });
                canvas.addEventListener('mousedown', (event) => { currentCanvasId = canvasId; startDrag(event); });
                canvas.addEventListener('mousemove', (event) => { currentCanvasId = canvasId; onDrag(event); });
                canvas.addEventListener('mouseup', (event) => { currentCanvasId = canvasId; endDrag(event); });
                canvas.addEventListener('mouseleave', () => { currentCanvasId = canvasId; endDrag(); });
            }

            window.onload = function() {
                addEvent(pointCanvasId);
                addEvent(polyLineCanvasId);
                addEvent(polygonCanvasId);

                pointTypeInit();
                polyLineInit();
                polygonTypeInit();
            }
        </script>
    </th:head>
    <th:body>
        <canvas id="pointMapCanvas" width="800" height="500" style="border:1px solid"></canvas>
        <canvas id="polyLineMapCanvas" width="800" height="500" style="border:1px solid"></canvas>
        <canvas id="polygonMapCanvas" width="800" height="500" style="border:1px solid"></canvas>
    </th:body>

</html>