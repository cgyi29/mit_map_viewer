<html xmlns:th="http://www.w3.org/1999/html" lang="en">
    <th:body>
        <canvas id="mapCanvas" width="800" height="600" style="border:1px solid"></canvas>
        <div id="dataDisplay" ></div>
    </th:body>

    <script th:inline="javascript">
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let dragStart = null;
        let lineWidth = 1;
        let pointSize = 1;
        let featureCollection = null;
        let mapCanvas = document.getElementById('mapCanvas');
        let dataDisplay = document.getElementById('dataDisplay');
        let largestBbox;

        let polyLines = [];
        let polygons = [];
        let points = [];

        let selectedPoints = [];
        let selectedPolylines = [];
        let selectedPolygons = [];


        const rectWidth = 60;
        const rectHeight = 60;

        let currentRectBbox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };

        window.onload = async function() {
            await featureCollectionInit();
            await drawMap();
            addCommonEventListeners();
        }

        function addCommonEventListeners() {
            mapCanvas.addEventListener('wheel', scrollHandler);
            mapCanvas.addEventListener('mousedown', startDrag);
            mapCanvas.addEventListener('mousemove', onDrag);
            mapCanvas.addEventListener('mouseup', endDrag);
            mapCanvas.addEventListener('mouseleave', endDrag);
            mapCanvas.addEventListener('click', onClick);
            mapCanvas.addEventListener('mousemove', drawRectangleWithCursor);
        }

        async function featureCollectionInit() {
            if (!featureCollection) {
                const res = await fetch('/v2/map/feature/tr/'+mapCanvas.width+'/'+mapCanvas.height);
                if (res.ok) {
                    const resData = await res.json();
                    featureCollection = Object.entries(resData)[0][1];
                    featureCollection.forEach(feature => {
                        largestBbox = feature.geometry.largestBbox;
                        switch (feature.geometry.type) {
                            case 'POINT': points.push(feature); break;
                            case 'POLYLINE': polyLines.push(feature); break;
                            case 'POLYGON': polygons.push(feature); break;
                        }
                    });
                }
            }
        }

        function drawMap(){
            const ctx = mapCanvas.getContext('2d');
            ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
            drawPolygon(ctx, polygons, 'pink');
            drawPolyLine(ctx, polyLines, 'green');
            drawPoint(ctx, points, 'blue' );
        }

        function drawPoint(ctx, pointsArr, color){
            if(mapCanvas.getContext) {
                pointSize = 1.5/zoom;
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                ctx.fillStyle=color;
                pointsArr.forEach((feature) => {
                    feature.geometry.coordinatesInfo.coordinates.forEach((coordinate) => {
                        ctx.beginPath();
                        ctx.arc(coordinate.x, coordinate.y, pointSize, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
                ctx.restore();
            }
        }

        function drawPolyLine(ctx, polylineArr, color) {
            if (mapCanvas.getContext) {
                lineWidth = 1/zoom;
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;

                polylineArr.forEach((feature) => {
                    const coordinates = feature.geometry.coordinatesInfo.coordinates;
                    const parts = feature.geometry.coordinatesInfo.parts;
                    parts.forEach((start, partIndex) => {
                        ctx.beginPath();
                        let end = coordinates.length;
                        if (partIndex < parts.length - 1) {
                            end = parts[partIndex + 1];
                        }
                        for (let i = start; i < end; i++) {
                            i === start ? ctx.moveTo(coordinates[i].x, coordinates[i].y): ctx.lineTo(coordinates[i].x, coordinates[i].y);
                        }
                        ctx.stroke();
                    });
                });
                ctx.restore();
            }
        }

        function drawPolygon(ctx, polygonArr, color){
            if (mapCanvas.getContext) {
                lineWidth = 1/zoom;
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                ctx.lineWidth = lineWidth;
                ctx.fillStyle = color;
                ctx.strokeStyle = 'black'; // 선 색상 추가

                polygonArr.forEach((feature) => {
                    const coordinates = feature.geometry.coordinatesInfo.coordinates;
                    ctx.beginPath(); // 각 다각형 시작 시에 한 번만 호출
                    coordinates.forEach((coordinate, index) => {
                        index === 0 ? ctx.moveTo(coordinate.x, coordinate.y) : ctx.lineTo(coordinate.x, coordinate.y);
                    });
                    ctx.closePath(); // 다각형 닫기
                    ctx.fill();
                    ctx.stroke();
                });
                ctx.restore();
            }
        }

        function scrollHandler(event) {
            event.preventDefault();
            const scaleAmount = event.deltaY < 0 ? 1.1 : 0.9;
            const cursorX = event.clientX - mapCanvas.getBoundingClientRect().left;
            const cursorY = event.clientY - mapCanvas.getBoundingClientRect().top;
            const worldX = (cursorX - panX) / zoom;
            const worldY = (cursorY - panY) / zoom;
            zoom *= scaleAmount;
            panX = cursorX - worldX * zoom;
            panY = cursorY - worldY * zoom;
            drawMap();
        }

        function startDrag(event) {
            dragStart = { x: event.clientX - panX, y: event.clientY - panY };
        }

        function onDrag(event) {
            if (dragStart !== null) {
                panX = event.clientX - dragStart.x;
                panY = event.clientY - dragStart.y;
                drawMap();
            }
        }

        function endDrag() {
            dragStart = null;
        }

        function drawRectangleWithCursor(event) {
            const rect = mapCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const ctx = mapCanvas.getContext('2d');
            ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
            drawMap();

            currentRectBbox = {
                minX: x - rectWidth / 2,
                minY: y - rectHeight / 2,
                maxX: x + rectWidth / 2,
                maxY: y + rectHeight / 2
            };

            ctx.fillStyle = 'rgba(0, 0, 255, 0)';
            ctx.fillRect(currentRectBbox.minX, currentRectBbox.minY, rectWidth, rectHeight);

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.strokeRect(currentRectBbox.minX, currentRectBbox.minY, rectWidth, rectHeight);

        }

        function onClick(event) {
            displayFeaturesInBBox(event);
        }

        function displayFeaturesInBBox(event) {
            dataDisplay.innerHTML = '';
            selectedPolygons = [];
            selectedPolylines = [];
            selectedPoints = [];
            const rect = mapCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const canvasX = (x-panX) /zoom;
            const canvasY = (y-panY) /zoom;


            let featuresInBBox = [];

            // 포인트 확인
            points.forEach(point => {
                if (isPointInsideBBox(currentRectBbox, transformCoordinate(point.geometry.coordinatesInfo.coordinates[0]))) {
                    console.log(point);
                    featuresInBBox.push(point.geometry.type);
                    selectedPoints.push(point);
                }
            });

            polyLines.forEach(polyline => {
                if (isPolylineIntersectingBBox(currentRectBbox, polyline.geometry.coordinatesInfo.coordinates)) {
                    featuresInBBox.push(polyline.properties.combinedInfo);
                    selectedPolylines.push(polyline);
                }
            });

            polygons.forEach(polygon => {
                if (isPolygonIntersectingBBox(currentRectBbox, polygon.geometry.coordinatesInfo.coordinates)) {
                    featuresInBBox.push(polygon.properties.combinedInfo);
                    selectedPolygons.push(polygon);
                    return;
                }
                if (isPointInPolygon({x:canvasX, y:canvasY}, polygon.geometry.coordinatesInfo.coordinates)) {
                    featuresInBBox.push(polygon.properties.combinedInfo);
                    selectedPolygons.push(polygon);
                }
            });

            dataDisplay.innerHTML = JSON.stringify(featuresInBBox, null, 2);

            const ctx = mapCanvas.getContext('2d');
            drawPolygon(ctx, selectedPolygons, 'yellow');
            drawPolyLine(ctx, selectedPolylines, 'red');
            drawPoint(ctx, selectedPoints, 'maroon');
        }

        function doLineSegmentsIntersect(a, b, c, d) {
            function crossProduct(p1, p2, p3) {
                return (p3.y - p1.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p3.x - p1.x);
            }

            function isPointOnLine(a, b, c) {
                return Math.min(a.x, b.x) <= c.x && c.x <= Math.max(a.x, b.x) &&
                    Math.min(a.y, b.y) <= c.y && c.y <= Math.max(a.y, b.y);
            }

            const d1 = crossProduct(a, b, c);
            const d2 = crossProduct(a, b, d);
            const d3 = crossProduct(c, d, a);
            const d4 = crossProduct(c, d, b);

            if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
                return true;
            }

            if (d1 === 0 && isPointOnLine(a, b, c)) return true;
            if (d2 === 0 && isPointOnLine(a, b, d)) return true;
            if (d3 === 0 && isPointOnLine(c, d, a)) return true;
            if (d4 === 0 && isPointOnLine(c, d, b)) return true;

            return false;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        function isPolylineIntersectingBBox(bbox, polyline) {
            for (let i = 0; i < polyline.length - 1; i++) {
                const segmentStart = transformCoordinate(polyline[i]);
                const segmentEnd = transformCoordinate(polyline[i + 1]);

                if (doLineSegmentsIntersect(segmentStart, segmentEnd, {x: bbox.minX, y: bbox.minY}, {x: bbox.maxX, y: bbox.minY}) ||
                    doLineSegmentsIntersect(segmentStart, segmentEnd, {x: bbox.maxX, y: bbox.minY}, {x: bbox.maxX, y: bbox.maxY}) ||
                    doLineSegmentsIntersect(segmentStart, segmentEnd, {x: bbox.maxX, y: bbox.maxY}, {x: bbox.minX, y: bbox.maxY}) ||
                    doLineSegmentsIntersect(segmentStart, segmentEnd, {x: bbox.minX, y: bbox.maxY}, {x: bbox.minX, y: bbox.minY})) {
                    return true;
                }

                if(isPointInsideBBox(bbox, segmentStart) && isPointInsideBBox(bbox, segmentEnd)){
                    return true;
                }
            }
            return false;
        }

        function isPolygonIntersectingBBox(bbox, polygon) {
            for (const vertex of polygon) {
                const transformedVertex = transformCoordinate(vertex);

                if (isPointInsideBBox(bbox, transformedVertex)) {
                    return true;
                }
            }
            if(isPolylineIntersectingBBox(bbox, polygon)){
                return true;
            }
        }

        function isPointInsideBBox(bbox, point) {
            return point.x >= bbox.minX && point.x <= bbox.maxX && point.y >= bbox.minY && point.y <= bbox.maxY;
        }

        function transformCoordinate(coordinate) {
            return {
                x: (coordinate.x * zoom) + panX,
                y: (coordinate.y * zoom) + panY
            };
        }
    </script>
</html>