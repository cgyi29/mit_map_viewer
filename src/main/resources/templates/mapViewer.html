<!DOCTYPE html>
<html xmlns:th="http://www.w3.org/1999/html" lang="en">
<th:head>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    <script th:inline="javascript">
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let dragStart = null;
        let currentCanvasId = '';

        let feature = {
            pointProp : [],
            pointGeom : [],
            polyLineProp : [],
            polyLineGeom : [],
            polygonProp : [],
            polygonGeom : [],
            pointObj: null,
            polyLineObj: null,
            polygonObj: null,
            largestBbox: { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
        };

        $( function() {
            let sortable = $( "#sortable" );
            sortable.sortable({update: function(event, ui) {updateCanvasOrder();}});
            sortable.disableSelection()
        });

        function updateCanvasOrder() {
            const orderedIds = $("#sortable").sortable("toArray", { attribute: "data-canvasid" });
            orderedIds.forEach((id, index) => {
                document.getElementById(id).style.zIndex = orderedIds.length - index;
            });

            const firstCanvasId = orderedIds[0];
            currentCanvasId = firstCanvasId;  // 현재 캔버스 ID를 설정
            removeCommonEventListeners();
            addCommonEventListeners();
            addClickEventListener(firstCanvasId);
        }

        function addCommonEventListeners() {
            ['pointMapCanvas', 'polyLineMapCanvas', 'polygonMapCanvas'].forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                canvas.addEventListener('wheel', scrollHandler);
                canvas.addEventListener('mousedown', startDrag);
                canvas.addEventListener('mousemove', onDrag);
                canvas.addEventListener('mouseup', endDrag);
                canvas.addEventListener('mouseleave', endDrag);
            });
        }

        function removeCommonEventListeners() {
            ['pointMapCanvas', 'polyLineMapCanvas', 'polygonMapCanvas'].forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    canvas.removeEventListener('wheel', scrollHandler);
                    canvas.removeEventListener('mousedown', startDrag);
                    canvas.removeEventListener('mousemove', onDrag);
                    canvas.removeEventListener('mouseup', endDrag);
                    canvas.removeEventListener('mouseleave', endDrag);
                }
            });
        }

        function addClickEventListener(canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.addEventListener('click', onClick);
        }

        async function pointInit() {
            if (!feature.pointObj) {
                const response = await fetch('/map/feature/Duraklar');
                if (response.ok) {
                    const responseData = await response.json();
                    feature.pointObj = responseData.geometry;
                    feature.pointProp = responseData.property.records;
                    updateLargestBBox(responseData.geometry.bbox);
                }
            }
        }

        async function polygonInit(){
            if (!feature.polygonObj) {
                const response = await fetch('/map/feature/KoyMahalle');
                if (response.ok) {
                    const responseData = await response.json();
                    feature.polygonObj = responseData.geometry;
                    feature.polygonProp = responseData.property.records;
                    updateLargestBBox(responseData.geometry.bbox);
                }
            }
        }

        async function polyLineInit(){
            if (!feature.polyLineObj) {
                const response = await fetch('/map/feature/Hatlar');
                if (response.ok) {
                    const responseData = await response.json();
                    feature.polyLineObj = responseData.geometry;
                    feature.polyLineProp = responseData.property.records;
                    updateLargestBBox(responseData.geometry.bbox);
                }
            }
        }

        async function drawPointCanvasMap(){
            const shapeData = await feature.pointObj;
            const points = await shapeData.points;
            const bbox = await  shapeData.bbox;

            const mapCanvas = document.getElementById('pointMapCanvas');
            if(mapCanvas.getContext) {
                const ctx = mapCanvas.getContext('2d');
                ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                ctx.save(); // translate, style, 클리핑 경로
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                ctx.fillStyle='blue';

                points.forEach((point, index) => {
                    let trPoint = scalePoint(point.x, point.y, bbox, mapCanvas);
                    ctx.beginPath();
                    ctx.arc(trPoint.x, trPoint.y, 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    feature.pointGeom.push({x:trPoint.x, y:trPoint.y, index: index});
                });
                ctx.restore();
            }
        }

        async function drawPolyLineCanvasMap(){
            const shapeData = await feature.polyLineObj;
            const polyLineData = await shapeData.polyTypeDatas;
            const bbox = await  shapeData.bbox;

            const mapCanvas = await document.getElementById('polyLineMapCanvas');
            if(mapCanvas.getContext){
                const ctx = await mapCanvas.getContext('2d');
                ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);
                ctx.strokeStyle='red';

                polyLineData.forEach(function(data){
                    data.parts.forEach(function() {
                        ctx.beginPath();
                        let transformedPoint = [];
                        data.points.forEach((pointData, index) => {
                            let point = scalePoint(pointData.x, pointData.y, bbox, mapCanvas);
                            transformedPoint.push(point);
                            index === 0 ? ctx.moveTo(point.x, point.y) : ctx.lineTo(point.x, point.y);
                        });
                        ctx.stroke();
                        feature.polyLineGeom.push(transformedPoint);
                    });
                });
                ctx.restore();
            }
        }

        async function drawPolygonCanvasMap(){
            const shapeData =  feature.polygonObj;
            const polygonData = await shapeData.polyTypeDatas;
            const bbox = await  shapeData.bbox;

            const mapCanvas = await document.getElementById('polygonMapCanvas');
            if(mapCanvas.getContext){
                const ctx = await mapCanvas.getContext('2d');
                ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoom, zoom);

                polygonData.forEach(function(data){
                    data.parts.forEach(function() {
                        ctx.beginPath();
                        let transformedPoint = [];
                        data.points.forEach((pointData, index) => {
                            let point = scalePoint(pointData.x, pointData.y, bbox, mapCanvas);
                            transformedPoint.push(point);
                            index === 0 ? ctx.moveTo(point.x, point.y):ctx.lineTo(point.x, point.y);
                        });
                        ctx.fillStyle = "yellow";
                        ctx.fill();
                        ctx.stroke();
                        feature.polygonGeom.push(transformedPoint);
                    });
                });
                ctx.restore();
            }
        }

        function updateLargestBBox(bbox) {
            feature.largestBbox.minX = Math.min(feature.largestBbox.minX, bbox.minX);
            feature.largestBbox.minY = Math.min(feature.largestBbox.minY, bbox.minY);
            feature.largestBbox.maxX = Math.max(feature.largestBbox.maxX, bbox.maxX);
            feature.largestBbox.maxY = Math.max(feature.largestBbox.maxY, bbox.maxY);
        }

        function onClick(event){
            if (!currentCanvasId) {
                console.error('currentCanvasId가 설정되지 않았습니다.');
                return;
            }
            const mapCanvas = document.getElementById(currentCanvasId);
            const rect = mapCanvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - panX) / zoom;
            const y = (event.clientY - rect.top - panY) / zoom;

            if(currentCanvasId === 'polyLineMapCanvas' ){
                const closestPolyLine = findClosestPolyLine(x,y);
                if(closestPolyLine != null){
                    displayPolyLineProp(closestPolyLine.index);
                }
            }

            if(currentCanvasId === 'polygonMapCanvas'){
                const clickPoint = { x: x, y: y};
                for (let i = 0; i < feature.polygonGeom.length; i++) {
                    if (isPointInPolygon(clickPoint, feature.polygonGeom[i])) {
                        displayPolygonProp(i);
                        break;
                    }
                }
            }

            if(currentCanvasId === 'pointMapCanvas') {
                const clickRadius = 10; // 클릭 반경 설정
                const closePoints = feature.pointGeom
                    .map((pointData, index) => {
                        const distance = Math.hypot(pointData.x - x, pointData.y - y);
                        return { pointData, distance, index };
                    })
                    .filter(point => point.distance <= clickRadius)
                    .sort((a, b) => a.distance - b.distance)
                    .map(point => feature.pointProp[point.index]);
                displayPointProp(closePoints);

            }
        }

        function isPointInPolygon(point, polygon) {
            let x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i].x, yi = polygon[i].y;
                let xj = polygon[j].x, yj = polygon[j].y;
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }


        function findClosestPolyLine(clickX, clickY) {
            let minDistance = Infinity;
            let closestPolyLineIndex = null;

            feature.polyLineGeom.forEach((line, index) => {
                for (let i = 0; i < line.length - 1; i++) {
                    let distance = distanceToLineSegment(clickX, clickY, line[i].x, line[i].y, line[i + 1].x, line[i + 1].y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPolyLineIndex = index;
                    }
                }
            });

            return closestPolyLineIndex != null ? { index: closestPolyLineIndex } : null;
        }

        function distanceToLineSegment(x, y, x1, y1, x2, y2) {
            const A = x-x1, B = y-y1, C = x2-x1, D = y2-y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            if (len_sq !== 0) {param = dot / len_sq; }

            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = x - xx;
            const dy = y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function displayPolygonProp(idx){
            document.getElementById('dataDisplay').innerText = JSON.stringify(feature.polygonProp[idx], null, 2);
        }

        function displayPointProp(closePoints){
            document.getElementById('dataDisplay').innerHTML = closePoints.map(attr => JSON.stringify(attr, null, 2)).join('<br><br>');
        }

        function displayPolyLineProp(idx){
            document.getElementById('dataDisplay').innerText = JSON.stringify(feature.polyLineProp[idx], null, 2);
        }

        function scalePoint(x, y, bbox, canvas) {
            let largestBbox = feature.largestBbox;

            if(bbox.minX===largestBbox.minX && bbox.minY===largestBbox.minY && bbox.maxX===largestBbox.maxX && bbox.maxY===largestBbox.maxY){
                let transformX = ((bbox.maxX - x) / (bbox.maxX - bbox.minX)) * canvas.width;
                let transformY = ((bbox.maxY - y) / (bbox.maxY - bbox.minY)) * canvas.height;
                transformX = canvas.width - transformX;
                return { x: transformX, y: transformY };
            }else{
                let adjustBbox = adjustBboxScale(bbox);
                let transformX = ((adjustBbox.maxX - x) / (adjustBbox.maxX - adjustBbox.minX)) * canvas.width;
                let transformY = ((adjustBbox.maxY - y) / (adjustBbox.maxY - adjustBbox.minY)) * canvas.height;
                transformX = canvas.width - transformX;
                return { x: transformX, y: transformY };
            }
        }

        function adjustBboxScale(bbox) {
            let scaleX = (feature.largestBbox.maxX - feature.largestBbox.minX) / (bbox.maxX - bbox.minX);
            let scaleY = (feature.largestBbox.maxY - feature.largestBbox.minY) / (bbox.maxY - bbox.minY);
            return {
                minX: feature.largestBbox.minX + (bbox.minX - bbox.minX) * scaleX,
                minY: feature.largestBbox.minY + (bbox.minY - bbox.minY) * scaleY,
                maxX: feature.largestBbox.minX + (bbox.maxX - bbox.minX) * scaleX,
                maxY: feature.largestBbox.minY + (bbox.maxY - bbox.minY) * scaleY
            };
        }

        function scrollHandler(event) {
            event.preventDefault();
            const scaleAmount = event.deltaY < 0 ? 1.1 : 0.9; // 줌 인과 줌 아웃에 대한 비율 조정
            const mapCanvas = document.getElementById(currentCanvasId);
            const cursorX = event.clientX - mapCanvas.getBoundingClientRect().left;
            const cursorY = event.clientY - mapCanvas.getBoundingClientRect().top;
            const worldX = (cursorX - panX) / zoom;
            const worldY = (cursorY - panY) / zoom;
            zoom *= scaleAmount;
            panX = cursorX - worldX * zoom;
            panY = cursorY - worldY * zoom;
            drawCanvas();
        }


        function startDrag(event) {
            dragStart = { x: event.clientX - panX, y: event.clientY - panY };
        }

        function onDrag(event) {
            if (dragStart !== null) {
                panX = event.clientX - dragStart.x;
                panY = event.clientY - dragStart.y;
                drawCanvas();
            }
        }

        function endDrag() {
            dragStart = null;
        }

        async function drawCanvas() {
            await drawPointCanvasMap();
            await drawPolyLineCanvasMap();
            await drawPolygonCanvasMap();
        }

        window.onload = async function() {
            await pointInit();
            await polyLineInit();
            await polygonInit();

            await drawCanvas();

            addCommonEventListeners();
            updateCanvasOrder();

        }
    </script>
</th:head>
<th:body>
    <div id="canvasContainer" style="position: relative; width: 800px; height: 500px;">
        <canvas id="pointMapCanvas" width="800" height="500" style="position: absolute; top: 0; left: 0; border:1px solid"></canvas>
        <canvas id="polyLineMapCanvas" width="800" height="500" style="position: absolute; top: 0; left: 0; border:1px solid"></canvas>
        <canvas id="polygonMapCanvas" width="800" height="500" style="position: absolute; top: 0; left: 0; border:1px solid"></canvas>
    </div>
    <div id="layerList" style="margin-top: 10px; width: 800px; border: 1px solid black;">
        <ul id="sortable">
            <li class="ui-state-default" data-canvasid="pointMapCanvas">Point Canvas</li>
            <li class="ui-state-default" data-canvasid="polyLineMapCanvas">Polyline Canvas</li>
            <li class="ui-state-default" data-canvasid="polygonMapCanvas">Polygon Canvas</li>
        </ul>
    </div>

    <div id="dataDisplay" style="border: 1px solid black; margin-top: 10px; width: 800px; height: 100px;"></div>
</th:body>

</html>